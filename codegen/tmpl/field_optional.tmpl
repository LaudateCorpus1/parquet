type {{.UpperParquetType}}OptionalField struct {
	parquet.OptionalField
	vals  []{{.ParquetType}}
	read  func(r *{{.OwnerType}}) ([]{{.ParquetType}}, []uint8, []uint8)
	write func({{.OwnerAlias}} *{{.OwnerType}}, vals []{{.ParquetType}}, def, rep []uint8) (int, int)
	stats *{{.ParquetType}}optionalStats
}

func New{{.UpperParquetType}}OptionalField(read func(r *{{.OwnerType}}) ([]{{.ParquetType}}, []uint8, []uint8), write func({{.OwnerAlias}} *{{.OwnerType}}, vals []{{.ParquetType}}, defs, reps []uint8) (int, int), path []string, types []int, opts ...func(*parquet.OptionalField)) *{{.UpperParquetType}}OptionalField {
	return &{{.UpperParquetType}}OptionalField{
		read:          read,
		write:         write,
		OptionalField: parquet.NewOptionalField(path, types, opts...),
		stats:         new{{.ParquetType}}optionalStats(maxDef(types)),
	}
}

func (f *{{.UpperParquetType}}OptionalField) Schema() parquet.Field {
	return parquet.Field{Name: f.Name(), Path: f.Path(), Type: {{.UpperParquetType}}Type, RepetitionType: f.RepetitionType, Types: f.Types}
}

func (f *{{.UpperParquetType}}OptionalField) Write(w io.Writer, meta *parquet.Metadata) error {
	var buf bytes.Buffer
	for _, v := range f.vals {
		if err := binary.Write(&buf, binary.LittleEndian, v); err != nil {
			return err
		}
	}
	return f.DoWrite(w, meta, buf.Bytes(), len(f.Defs), f.stats)
}

func (f *{{.UpperParquetType}}OptionalField) Read(r io.ReadSeeker, pg parquet.Page) error {
	rr, _, err := f.DoRead(r, pg)
	if err != nil {
		return err
	}

	v := make({{.ParquetType}}, f.Values()-len(f.vals))
	err = binary.Read(rr, binary.LittleEndian, &v)
	f.vals = append(f.vals, v...)
	return err
}

func (f *{{.UpperParquetType}}OptionalField) Add({{.OwnerAlias}} *{{.OwnerType}}) {
	vals, defs, reps := f.read({{.OwnerAlias}})
	f.stats.add(vals, defs)
	f.vals = append(f.vals, vals...)
	f.Defs = append(f.Defs, defs...)
	f.Reps = append(f.Reps, reps...)
}

func (f *{{.UpperParquetType}}OptionalField) Scan({{.OwnerAlias}} *{{.OwnerType}}) {
	if len(f.Defs) == 0 {
		return
	}

	v, l := f.write({{.OwnerAlias}}, f.vals, f.Defs, f.Reps)
	f.vals = f.vals[v:]
	f.Defs = f.Defs[l:]
	if len(f.Reps) > 0 {
		f.Reps = f.Reps[l:]
	}
}

func (f *{{.UpperParquetType}}OptionalField) Levels() ([]uint8, []uint8) {
	return f.Defs, f.Reps
}


type {{.ParquetType}}optionalStats struct {
	min     {{.ParquetType}}
	max     {{.ParquetType}}
	nils    int64
	nonNils int64
	maxDef  uint8
}

func new{{.ParquetType}}optionalStats(d uint8) *{{.ParquetType}}optionalStats {
	return &{{.ParquetType}}optionalStats{
		min:    {{.ParquetType}}(math.Max{{.UpperParquetType}}),
		maxDef: d,
	}
}

func (f *{{.ParquetType}}optionalStats) add(vals []{{.ParquetType}}, defs []uint8) {
	var i int
	for _, def := range defs {
		if def < f.maxDef {
			f.nils++
		} else {
			val := vals[i]
			i++

			f.nonNils++
			if val < f.min {
				f.min = val
			}
			if val > f.max {
				f.max = val
			}
		}
	}
}

func (f *{{.ParquetType}}optionalStats) bytes(val {{.ParquetType}}) []byte {
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, val)
	return buf.Bytes()
}

func (f *{{.ParquetType}}optionalStats) NullCount() *int64 {
	return &f.nils
}

func (f *{{.ParquetType}}optionalStats) DistinctCount() *int64 {
	return nil
}

func (f *{{.ParquetType}}optionalStats) Min() []byte {
	if f.nonNils == 0 {
		return nil
	}
	return f.bytes(f.min)
}

func (f *{{.ParquetType}}optionalStats) Max() []byte {
	if f.nonNils == 0 {
		return nil
	}
	return f.bytes(f.max)
}