// Code generated by Gojay. DO NOT EDIT.

package poc

import (
	"github.com/francoispqt/gojay"
)

type SampledSubjects []SampledSubject

func (s *SampledSubjects) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value = SampledSubject{}
	if err := dec.Object(&value); err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func (s SampledSubjects) MarshalJSONArray(enc *gojay.Encoder) {
	for i := range s {
		enc.Object(&s[i])
	}
}

func (s SampledSubjects) IsNil() bool {
	return len(s) == 0
}

type Int64s []int64

// UnmarshalJSONArray decodes JSON array elements into slice
func (a *Int64s) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value int64
	if err := dec.Int64(&value); err != nil {
		return err
	}
	*a = append(*a, value)
	return nil
}

// MarshalJSONArray encodes arrays into JSON
func (a Int64s) MarshalJSONArray(enc *gojay.Encoder) {
	for _, item := range a {
		enc.Int64(item)
	}
}

// IsNil checks if array is nil
func (a Int64s) IsNil() bool {
	return len(a) == 0
}

type Strings []string

// UnmarshalJSONArray decodes JSON array elements into slice
func (a *Strings) UnmarshalJSONArray(dec *gojay.Decoder) error {
	var value string
	if err := dec.String(&value); err != nil {
		return err
	}
	*a = append(*a, value)
	return nil
}

// MarshalJSONArray encodes arrays into JSON
func (a Strings) MarshalJSONArray(enc *gojay.Encoder) {
	for _, item := range a {
		enc.String(item)
	}
}

// IsNil checks if array is nil
func (a Strings) IsNil() bool {
	return len(a) == 0
}

// MarshalJSONObject implements MarshalerJSONObject
func (s *SampledSubject) MarshalJSONObject(enc *gojay.Encoder) {
	enc.Int64KeyOmitEmpty("creativeID", *s.CreativeID)
	enc.Int64KeyOmitEmpty("audienceID", *s.AudienceID)
	enc.Int64KeyOmitEmpty("adOrderID", *s.AdOrderID)
	enc.StringKeyOmitEmpty("filter", *s.Filter)
	enc.BoolKeyOmitEmpty("passed", *s.Passed)
	enc.BoolKeyOmitEmpty("sampled", *s.Sampled)
}

// IsNil checks if instance is nil
func (s *SampledSubject) IsNil() bool {
	return s == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (s *SampledSubject) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {

	switch k {
	case "creativeID":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.CreativeID = &value
		}
		return err

	case "audienceID":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.AudienceID = &value
		}
		return err

	case "adOrderID":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.AdOrderID = &value
		}
		return err

	case "filter":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.Filter = &value
		}
		return err

	case "passed":
		var value bool
		err := dec.Bool(&value)
		if err == nil {
			s.Passed = &value
		}
		return err

	case "sampled":
		var value bool
		err := dec.Bool(&value)
		if err == nil {
			s.Sampled = &value
		}
		return err

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (s *SampledSubject) NKeys() int { return 6 }

// MarshalJSONObject implements MarshalerJSONObject
func (s *Selection) MarshalJSONObject(enc *gojay.Encoder) {
	enc.StringKeyOmitEmpty("timestamp", *s.Timestamp)
	enc.StringKeyOmitEmpty("sid", *s.SID)
	enc.StringKeyOmitEmpty("auctionId", *s.AuctionID)
	enc.StringKeyOmitEmpty("hostNodeIp", *s.HostNodeIP)
	enc.StringKeyOmitEmpty("hostNodeVersion", *s.HostNodeVersion)
	enc.StringKeyOmitEmpty("endpoint", *s.Endpoint)
	enc.Int64KeyOmitEmpty("timeTakenMcs", *s.TimeTakenMcs)
	enc.StringKeyOmitEmpty("ip", *s.IP)
	enc.Int64KeyOmitEmpty("publisherID", *s.PublisherID)
	enc.Int64KeyOmitEmpty("siteId", *s.SiteID)
	enc.BoolKeyOmitEmpty("filtered", *s.Filtered)
	enc.BoolKeyOmitEmpty("aborted", *s.Aborted)
	enc.BoolKeyOmitEmpty("throttled", *s.Throttled)
	enc.StringKeyOmitEmpty("error", *s.Error)
	var timeoutsSlice = Strings(s.Timeouts)
	enc.ArrayKeyOmitEmpty("timeouts", timeoutsSlice)
	enc.Int64KeyOmitEmpty("passed", *s.Passed)
	var selectableAdOrdersSlice = Int64s(s.SelectableAdOrders)
	enc.ArrayKeyOmitEmpty("selectableAdOrders", selectableAdOrdersSlice)
	var selectableAudiencesSlice = Int64s(s.SelectableAudiences)
	enc.ArrayKeyOmitEmpty("selectableAudiences", selectableAudiencesSlice)
	enc.Int64KeyOmitEmpty("phase", *s.Phase)
	var sampledSubjectsSlice = SampledSubjects(s.SampledSubjects)
	enc.ArrayKeyOmitEmpty("sampledSubjects", sampledSubjectsSlice)
}

// IsNil checks if instance is nil
func (s *Selection) IsNil() bool {
	return s == nil
}

// UnmarshalJSONObject implements gojay's UnmarshalerJSONObject
func (s *Selection) UnmarshalJSONObject(dec *gojay.Decoder, k string) error {

	switch k {
	case "timestamp":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.Timestamp = &value
		}
		return err

	case "sid":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.SID = &value
		}
		return err

	case "auctionId":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.AuctionID = &value
		}
		return err

	case "hostNodeIp":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.HostNodeIP = &value
		}
		return err

	case "hostNodeVersion":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.HostNodeVersion = &value
		}
		return err

	case "endpoint":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.Endpoint = &value
		}
		return err

	case "timeTakenMcs":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.TimeTakenMcs = &value
		}
		return err

	case "ip":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.IP = &value
		}
		return err

	case "publisherID":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.PublisherID = &value
		}
		return err

	case "siteId":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.SiteID = &value
		}
		return err

	case "filtered":
		var value bool
		err := dec.Bool(&value)
		if err == nil {
			s.Filtered = &value
		}
		return err

	case "aborted":
		var value bool
		err := dec.Bool(&value)
		if err == nil {
			s.Aborted = &value
		}
		return err

	case "throttled":
		var value bool
		err := dec.Bool(&value)
		if err == nil {
			s.Throttled = &value
		}
		return err

	case "error":
		var value string
		err := dec.String(&value)
		if err == nil {
			s.Error = &value
		}
		return err

	case "timeouts":
		var aSlice = Strings{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			s.Timeouts = []string(aSlice)
		}
		return err

	case "passed":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.Passed = &value
		}
		return err

	case "selectableAdOrders":
		var aSlice = Int64s{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			s.SelectableAdOrders = []int64(aSlice)
		}
		return err

	case "selectableAudiences":
		var aSlice = Int64s{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			s.SelectableAudiences = []int64(aSlice)
		}
		return err

	case "phase":
		var value int64
		err := dec.Int64(&value)
		if err == nil {
			s.Phase = &value
		}
		return err

	case "sampledSubjects":
		var aSlice = SampledSubjects{}
		err := dec.Array(&aSlice)
		if err == nil && len(aSlice) > 0 {
			s.SampledSubjects = []SampledSubject(aSlice)
		}
		return err

	}
	return nil
}

// NKeys returns the number of keys to unmarshal
func (s *Selection) NKeys() int { return 20 }
